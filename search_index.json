[
["index.html", "Tutorial Preface", " Tutorial fangjinuo 2019-12-28 Preface langx-java: Java lang extensions，a supplement to , replacement of a Guava, commons-lang. easyjson: Provides an unified JSON access API, you can adapter any JSON library to Gson, Jackson, FastJson with easyjson sqlhelper: SQL Tools ( Dialect, Pagination, DDL dump, UrlParser, SqlStatementParser, WallFilter, BatchExecutor for Test) based Java. "],
["langx-java-outline.html", "Chapter 1 outline 1.1 Repository 1.2 Versions 1.3 Features 1.4 Contact", " Chapter 1 outline Java lang extensions，a supplement to , replacement of a Guava, commons-lang 1.1 Repository GitHub: https://github.com/fangjinuo/langx-java Gitee: https://gitee.com/fangjinuo/langx-java 1.2 Versions 1.3 Features Lang extensions, for examples: Bytes, Chars, Arrays, Numbers, Dates, Throwables, Filenames, Files, FileSystems … Collection extensions: Supports Stream API for Java 6+ Adapter any object to Iterable Supports NonAbsentMap, using it, the map.get(key) will not return the null Supports NonDistinctTreeSet, NonDistinctTreeMap, just sort Supports Tuple Supports WheelQueue, CopyOnWriteHashMap NamedInheritableThreadLocal IdentityMap IdentitySet WeakIdentityHashMap ConcurrentReferenceHashMap Differ API Collection Differ Map Differ Cache Local Cache LRUCache FIFOCache Accessor API Tuple Environment Accessor Properties Accessor Map Accessor StringMap Accessor Field Accessor Array Accessor HTTP Query String Accessor Reflect utilities Modifiers Reflects Types Primitives timing HashedWheelTimer Linux NTP Cron Joda-time Clock StopWatch JavaScript in Java IdGenerator AutoIncrementIdGenerator Base64IdGenerator SimpleIdGenerator UuidGenerator SnowflakeIdGenerator Proxy AOP delegate Base64 for Java 6+ text CSV Pinyin StringTemplate placeholder: {} index: {0}, {1} C style: %d, %s … bean : ${fieldName1}, ${fieldName2} map: ${key1}, ${key2} Null judge is unnecessary Environment SystemEnvironment Event API Comparators Parse Hosts File Codec ClassPath Scanner Local JNDI Security checksum Radix converter JMX management API File Filter ExecutableFilter ExistsFileFilter FilenamePrefixFilter FilenameSuffixFilter IsDirectoryFileFilter IsFileFilter IsHiddenFileFilter IsSymlinkFileFilter ReadableFileFilter ReadonlyFileFilter ValidFilenameFilter WriteableFileFilter Lifecycle API ClassParser Converter Service BloomFilter IO Resource Load API Common Configuration API Multiple Level Jar URLStreamHandler Escaper API Delimiter Channel 1.4 Contact 如果遇到问题，可以在Github, Gitee 上提出issue, 也可以在QQ群里询问。 代码提交以GitHub为主，会定期同步到Gitee。 QQ Group: 750929088 "],
["langx-java-installation.html", "Chapter 2 Installation", " Chapter 2 Installation &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.langx&lt;/groupId&gt; &lt;artifiedId&gt;langx-java&lt;/artifiedId&gt; &lt;version&gt;${langx.version}&lt;/version&gt; &lt;/dependency&gt; "],
["lanx-java-references-utils.html", "Chapter 3 Basic utility 3.1 Emptys 3.2 Objects 3.3 Strings 3.4 Numbers 3.5 Bytes 3.6 Chars 3.7 Radixs 3.8 Maths", " Chapter 3 Basic utility 3.1 Emptys In any java project, you can often see the following code: // scenario 1: String s = method1(args); if(s != null &amp;&amp; s.length() &gt; 0){ ... } // scenario 2: List&lt;String&gt; list = method2(args); if(list != null &amp;&amp; !list.isEmpty()){ ... } // or if(list != null &amp;&amp; list.size() &gt; 0){ ... } // scenario 3: int[] array = method3(args); if(array != null &amp;&amp; array.length &gt; 0){ ... } // scenario 4: Map&lt;String, Integer&gt; map = method4(args); if(map != null &amp;&amp; map.size() &gt; 0){ ... } to avoid these vomiting code, supply some simple code: // scenario 1: String s = method1(args); if(Emptys.isNotEmpty(s)){ ... } // scenario 2: List&lt;String&gt; list = method2(args); if(Emptys.isNotEmpty(list)){ ... } // scenario 3: int[] array = method3(args); if(Emptys.isNotEmpty(array)){ ... } // scenario 4: Map&lt;String, Integer&gt; map = method4(args); if(Emptys.isNotEmpty(map)){ ... } wow, you can use Emptys.isNotEmpty() to judge any object is not empty. public static boolean isNotEmpty(Object o) { return !isEmpty(o); } public static boolean isEmpty(Object object) { if (object == null) { return true; } if (object instanceof String) { return Strings.isEmpty((String) object); } if (object instanceof CharSequence) { CharSequence cs = (CharSequence) object; return cs.length() == 0; } if (object instanceof Number) { return isZero((Number) object); } if (object instanceof Buffer) { Buffer buff = (Buffer) object; return buff.hasRemaining(); } if (object instanceof Collection) { return ((Collection) object).isEmpty(); } if (object instanceof Map) { return ((Map) object).isEmpty(); } if (object.getClass().isArray()) { return Arrs.getLength(object) &lt;= 0; } if (object.getClass().isEnum()) { return false; } return false; } 3.2 Objects in java 7 ~ 9 , supply a object utility class: java.util.Objects, many convenient methods in it: public static boolean equals(Object a, Object b); public static boolean deepEquals(Object a, Object b); public static int hashCode(Object o); public static int hash(Object... values); public static String toString(Object o); public static String toString(Object o, String nullDefault); public static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c); public static boolean isNull(Object obj); public static boolean nonNull(Object obj); public static &lt;T&gt; T requireNonNull(T obj); public static &lt;T&gt; T requireNonNull(T obj, String message); public static &lt;T&gt; T requireNonNullElse(T obj, T defaultObj); public static &lt;T&gt; T requireNonNullElseGet(T obj, Supplier&lt;? extends T&gt; supplier); public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier); public static int checkIndex(int index, int length); public static int checkFromToIndex(int fromIndex, int toIndex, int length); public static int checkFromIndexSize(int fromIndex, int size, int length); to using the utility class, I migrate it to langx-java, named com.jn.langx.util.Objects. It contain all above methods, supply the following methods: public static &lt;T&gt; T useValueIfNull(T value, T defaultValue); // it is similar to requireNonNullElse public static boolean isNotNull(Object obj); // equals: nonNull public static boolean isEmpty(Object o); // based on Emptys.isEmpty() public static boolean isNotEmpty(Object o);// based on Emptys.isNotEmpty() 3.3 Strings There are 40% code is string processing in a program, so we’re going to have a variety of string processing scenarios. public static boolean isEmpty(String str); public static boolean isNotEmpty(String str); public static boolean isBlank(String str); public static boolean isNotBlank(String str; public static String useValueIfNull(String str, String defaultValue); public static String useValueIfBlank(String str, String defaultValue); public static String useValueIfEmpty(String str, String defaultValue); public static String getEmptyIfNull(String str); public static String getEmptyIfBlank(String str); public static String getNullIfEmpty(String str); public static String getNullIfBlank(String str); public static String trimOrEmpty(String str); public static String truncate(@NonNull final String string, final int length); public static String join(@NonNull final String separator, @Nullable final Iterator objects); public static String join(@NonNull final String separator, @Nullable final Iterable objects); public static String join(@NonNull final String separator, @Nullable final Object[] objects); public static String join(@NonNull final String separator, @Nullable final Integer[] objects); public static String join(@NonNull final String separator, @Nullable final Long[] objects); public static String join(@NonNull final String separator, @Nullable final Float[] objects); public static String join(@NonNull final String separator, @Nullable final Double[] objects); public static String join(@NonNull final String separator, @Nullable final Short[] objects); public static String join(@NonNull final String separator, @Nullable final Byte[] objects); public static String join(@NonNull final String separator, @Nullable final Character[] objects); public static String join(@NonNull final String separator, @Nullable final String[] objects); public static String[] split(@Nullable String string, @Nullable String separator); public static boolean substringMatch(CharSequence str, int index, CharSequence substring); public static byte[] getBytesUtf8(final String string); public static String newStringUtf8(final byte[] bytes); public static String deleteWhitespace(String str); public static String removeDuplicateWhitespace(String s); public static String unifyLineSeparators(String s); public static String unifyLineSeparators(String s, String lineSeparator); public static boolean isNumeric(final CharSequence cs); public static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length); public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix); public static boolean startsWith(final CharSequence str, final CharSequence prefix); public static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase); public static boolean endsWith(final CharSequence str, final CharSequence suffix); public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix); public static boolean containsAny(final CharSequence cs, final char... searchChars); public static boolean containsAny(final CharSequence cs, final CharSequence searchChars); public static String repeat(final String str, final int repeat); public static String repeat(final String str, final String separator, final int repeat); public static String repeat(final char ch, final int repeat); public static String rightPad(final String str, final int size); public static String rightPad(final String str, final int size, final char padChar); public static String rightPad(final String str, final int size, String padStr); public static String leftPad(final String str, final int size); public static String leftPad(final String str, final int size, final char padChar); public static String leftPad(final String str, final int size, String padStr); ... more methods your can find from javadocs 3.4 Numbers convert a string to a number public static Float createFloat(String str); public static Double createDouble(String str); public static Integer createInteger(String str); public static Long createLong(String str); public static BigInteger createBigInteger(String str); public static BigDecimal createBigDecimal(String str); public static boolean isDigits(String str); public static boolean isNumber(String str); public static Number createNumber(String str); public static &lt;T extends Number&gt; T parseNumber(String text, Class&lt;T&gt; targetClass); public static &lt;T extends Number&gt; T parseNumber(String text, Class&lt;T&gt; targetClass, @Nullable NumberFormat numberFormat) 3.5 Bytes Byte utility methods: public static long fromLittleEndian(byte[] bytes); public static long fromLittleEndian(byte[] bytes, final int off, final int length); public static long fromLittleEndian(InputStream in, int length); public static long fromLittleEndian(ByteSupplier supplier, final int length); public static long fromLittleEndian(DataInput in, int length); public static void toLittleEndian(final byte[] b, final long value, final int off, final int length); public static void toLittleEndian(OutputStream out, final long value, final int length); public static void toLittleEndian(ByteConsumer consumer, final long value, final int length); public static void toLittleEndian(DataOutput out, final long value, final int length); public static byte toLowerCase(byte c); public static byte toUpperCase(byte b); public static boolean isLowerCase(byte value); public static boolean isUpperCase(byte value); 3.6 Chars Char utility methods: public static boolean isAlphabetic(int codePoint); public static boolean isAscii(final char ch); public static boolean isAsciiPrintable(final char ch); public static boolean isNumber(final char c); public static int toInt(char c); public static char toLowerCase(char c); public static byte toLowerCase(byte c); public static byte toUpperCase(byte b); public static char toUpperCase(char b); public static boolean isLowerCase(byte value); public static boolean isLowerCase(char value); public static boolean isUpperCase(byte value); public static boolean isUpperCase(char value); public static boolean isLowOrUpperCase(char value); public static boolean isLowOrUpperCase(byte value); public static byte c2b(char c); public static char b2c(byte b); public static int compare(final char x, final char y); 3.7 Radixs Radix converter, convet a byte,byte[], char, char[], short, short[], int, int[], long, long[] to binary, otc, decimal, hex. // convert a int to n radix; public static String toRadix(int b, int radix); public static String toBinary(byte b); public static String toBinary(char b); public static String toBinary(short b); public static String toBinary(int b); public static String toBinary(long b); public static String toOtc(byte b); public static String toOtc(char b); public static String toOtc(short b); public static String toOtc(int b); public static String toOtc(long b); public static String toDecimal(byte b); public static String toDecimal(char b); public static String toDecimal(short b); public static String toDecimal(int b); public static String toDecimal(long b); public static String toHex(byte b); public static String toHex(char b); public static String toHex(short b); public static String toHex(int b); public static String toHex(long b); public static String toHex2(byte b); public static String toHex2(char b); public static String toHex2(short b); public static String toHex2(int b); public static String toHex2(long b); public static String toHex(byte[] bytes); public static String toHex2(byte[] bytes); 3.8 Maths Math compute methods: public static int max(int... array); public static float max(float... array); public static long max(long... array); public static doule max(doule... array); public static int min(int... array); public static float min(float... array); public static long min(long... array); public static doule min(doule... array); public static int abs(int value); public static int max(int... array); public static float max(float... array); public static long max(long... array); public static doule max(doule... array); public static int sum(int... array); public static float sum(float... array); public static long sum(long... array); public static doule sum(doule... array); public static int avg(int... array); public static float avg(float... array); public static long avg(long... array); public static doule avg(doule... array); public static boolean isOutOfBounds(int index, int length, int capacity); "],
["langx-java-references-package-Struct.html", "Chapter 4 Common Struct 4.1 Pair 4.2 Entry 4.3 Holder", " Chapter 4 Common Struct Holder, Pair, Entry etc 4.1 Pair the key-value pair public abstract class Pair&lt;K, V&gt; { private K key; private V value; public K getKey() { return key; } public V getValue() { return value; } public void setKey(K key) { this.key = key; } public V setValue(V value) { V old = this.value; this.value = value; return old; } @Override public boolean equals(Object object) { if (this == object) { return true; } if (object == null || getClass() != object.getClass()) { return false; } Pair that = (Pair) object; return key.equals(that.key) &amp;&amp; value.equals(that.key); } } all subtypes: DoubleNameValuePair Entry IntegerNameValuePair LongNameValuePair NameValuePair StringNameValuePair 4.2 Entry Entry extends the Pair class, and the following methods are provided public static Entry&lt;String, String&gt; newEntry(String keyValue, String spec); public static Map&lt;String, String&gt; getMap(String str, String keyValueSpec, String entrySpec); public static List&lt;Map&lt;String, String&gt;&gt; getMapList(String src, String keyValueSpec, String entrySpec, String listSpecFlag); 4.3 Holder the value holder public class Holder&lt;V&gt; { private V v; public Holder() { } public Holder(final V value) { this.set(value); } public void set(final V value) { this.v = value; } public V get() { return this.v; } } "],
["sqlhelper-outline.html", "Chapter 5 Outline 5.1 Versions 5.2 Features 5.3 Architecture 5.4 Supports Databases", " Chapter 5 Outline SQL Tools ( Dialect, Pagination, DDL Dump, UrlParser, SqlStatementParser, WallFilter, BatchExecutor for Test) based Java 5.1 Versions 5.2 Features Pagination Supports Mybatis, Mybatis-plus, SpringJDBC, Apache Commons-DBUtils, JFinal, EBean, Mango… Supports multiple databases in one application Supports auto detect dialect, so the dialect option is optional Supports plugin use Java SPI Supports spring boot 1.x , 2.x Supports JDK 6+ Supports Memory Pagination Supports SqlSymbolMapper, use it you can mapping any symbol to SQL symbol Supports subquery pagination for mybatis, spring-jdbc, apache commons-dbutils Supports 110+ databases, contains all most Chinese databases AliSQL (阿里 MySQL) AntDB (亚信) CirroDB (东方国信 行云) CynosDB (腾讯云数据库) Doris (Apache Doris，百度研发) DM (达梦) EsgynDB (易鲸捷) GaussDB (华为 高斯) GBase (南大通用) GoldenDB (中兴) HHDB (恒辉数据库) HighGo (瀚高) HybridDB (阿里巴巴 分布式PostgreSQL) K-DB (浪潮) KingBase (金仓) MaxCompute (阿里巴巴) OBase (上海丛云信息科技) OceanBase (阿里巴巴/蚂蚁金服 兼容mysql) OSCAR (神州通用) OpenBase (东软) RadonDB (青云) SequoiaDB (巨杉) SinoDB (星瑞格) TDSQL (腾讯 分布式MySQL) TiDB (北京平凯星辰科技)) Trafodion (易鲸捷 EsgynDB的开源版) DDL Dumper URL Parser Batch Executor for Tester 5.3 Architecture sqlhelper architecutre Dialect is a core class, use it, you can parseURL, set limit, offset for a pagination request, escape the like parameters, generate table’s DDL etc. Every database will has a dialect. DialectRegistry is the dialect registry centeral LikeEscaper use it to avoid some keywords (%, _ …) in like clause UrlParser parse jdbc url SQLStatementInstrumentor instrument some string to a sepicified Sql statement Pagination common pagination, will be used in mybatis, spring-jdbc, apacha commons-dbutils, mango, ebean, jfinal … ResultSetExtractor the resultset extractor, extract a result to any you expected. so you can use in any jdbc framework BatchUpdater supply 3 batch update mode: BATCH_SQL: use database’s batch sql JDBC_BATCH: use jdbc batch operation SIMPLE: just insert or update in a for loop ConnectionManager support custom connection configuration, datasource … BatchInsertExecutor batch insert a large dataset to database SqlFormatter format a sql TableGenerator a table DDL generator TableDDLDumper dump the ddl of any table 5.4 Supports Databases Supports the following databases, your can find them in DBEngines: A Access ActorDB AgensGraph Altibase AliSQL (阿里巴巴, 兼容 mysql) AntDB (亚信) Aurora (Amazon Aurora) Azure (Microsoft Azure Cloud Database) B BigObject Brytlyt C Cache (CacheDB) CirroDB (东方国信 行云) Citus ClickHouse ClustrixDB Cobol Cockroach ComDB2 Covenant Crate CTree (CTreeACE, CTreeEDGE, CTreeRTG) Cubrid CynosDB (腾讯云数据库，兼容mysql, PostgreSQL) D DB2 DBF Derby DM (达梦数据库) Doris (Apache Doris, 百度研发) Drill (Apache Drill) E Elasticsearch EsgynDB F FileMaker Firebird G GaussDB (华为 高斯数据库) GBase (南大通用) GoldenDB Greenplum H H2 HANA (SAP HANAColumn, HANAStore) Hawq (Apache Hawq) HerdDB HhDB HighGo (瀚高数据库) Hive HSQL I Ignite (Apache Ignite) Impala (Apache Impala) Informix Ingres Interbase Iris J JDataStore K K-DB (浪潮数据库) KarelDB KingBase (人大金仓) Kinetica Kognitio L LeanXcale Linter M MariaDb MaxCompute (阿里巴巴 飞天) MAXDB (SAP MaxDB) Mckoi MemSQL MimerSQL Monet MSQL (MiniSQL) MySQL N Neo4j Netezza (IBM Netezza) NexusDB NuoDB O OBase OceanBase (阿里巴巴) Omnisci OpenBase (东软集团) OpenEdge Oracle (8i,9,9i,10g,11g,12c) OrientDB OSACR (神通数据库) P Paradox PerconaMySQL Phoenix (HBase JDBC Client) PostgreSQL Presto R RadonDB Raima RBase RDMSOS2200 Redshift (Amazon Redshift) S Sadas SequoiaDB (巨杉数据库) SinoDB (星瑞格) Small SnappyData SnowflakeDialect SpliceMachine SQLite SQLServer (SQLServer 2005,2008,2012,2017) SQream T Tajo TDSQL (腾讯 分布式mysql) Teradata TiDB (北京平凯星辰科技) TimesTen Trafodion Transbase U UXDB (优炫数据库) V Valentina Vertica Virtuoso VistaDB VoltDB X Xtreme (EXtremeSQL, XtremeData) Y Yaacomo YugabyteDB "],
["sqlhelper-pagination.html", "Chapter 6 Pagination 6.1 Configuration 6.2 MyBatis Application 6.3 MyBatis + Spring Boot 6.4 MyBatis-plus + Spring Boot Application 6.5 Migrate from PageHelper 6.6 SpringJDBC Application 6.7 Apache DBUtils Application 6.8 Usage 6.9 How to Integrate", " Chapter 6 Pagination 6.1 Configuration There are two types of configurations for pagination: Instrumentator configurations: (you can find out com.jn.sqlhelper.dialect.pagination.SQLInstrumentConfig from source) dialect: the database dialect, if sqlhelper can’t find a right database dialect, you can use it dialectClassName: your custom dialect class cacheInstrumentedSql: whether cache all instrumentd sql, use it to avoid instrument a sql again, defualt is false subqueryPagingStartFlag: the start flag of a subquery sql , the default value is [PAGING_START] subqueryPagingEndFlag: the end flag of a subquery sql, the defulat value is [PAGING_END] pagination plugin common configurations: (you can find out com.jn.sqlhelper.dialect.pagination.PaginationProperties from source) count : where execute select count, the default value is true defaultPageSize: the default page size, if your pageNo &gt;0, but the pageSize is not set, will using it. the default value is 10 useLastPageIfPageNoOut: whether get the last page records when your pageNo &gt; maxPages, the defulat value is false Some plugin specified configurations will be described in themselves. 6.2 MyBatis Application 6.2.1 installation import dependencies: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-mybatis&lt;/artifactId&gt; &lt;version&gt;${sqlhelper.version}&lt;/version&gt; &lt;/dependency&gt; config mybatis-config.xml: &lt;configuration&gt; ... &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt; &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt; &lt;/databaseIdProvider&gt; ... &lt;settings&gt; ... &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;com.jn.sqlhelper.mybatis.plugins.pagination.CustomScriptLanguageDriver&quot; /&gt; ... &lt;/settings&gt; ... &lt;/configuration&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.jn.sqlhelper.mybatis.plugins.pagination.MybatisPaginationPlugin&quot;&gt; &lt;property name =&quot;sqlhelper.mybatis.instrumentor.dialect&quot; value=&quot;mysql&quot; /&gt; &lt;property name =&quot;sqlhelper.mybatis.instrumentor.cacheInstruemtedSql&quot; value=&quot;true&quot; /&gt; &lt;property name =&quot;sqlhelper.mybatis.pagination.count&quot; value=&quot;true&quot; /&gt; &lt;property name =&quot;sqlhelper.mybatis.pagination.defaultPageSize&quot; value=&quot;defaultPageSize&quot; /&gt; &lt;property name =&quot;sqlhelper.mybatis.pagination.useLastPageIfPageNoOut&quot; value=&quot;useLastPageIfPageNoOut&quot; /&gt; &lt;property name =&quot;sqlhelper.mybatis.pagination.countSuffix&quot; value=&quot;_COUNT&quot; /&gt; &lt;/plugin&gt; &lt;/plugins&gt; 6.2.1 Usage @GetMapping(&quot;/_useMyBatis&quot;) public PagingResult list_useMyBatis( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort) { User queryCondition = new User(); queryCondition.setAge(10); PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); List&lt;User&gt; users = userDao.selectByLimit(queryCondition); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } more examples you can find out from UserController class in sqlhelper-exmples 6.2.2 specified configurations to performance, supply a count sql statement cache , you can configure it like: countCacheInitCapacity: the initial capacity of count sql statement cache, the default value is 10 countCacheMaxCapacity: the max capacity of count sql statement cache, the default values is 1000, if you don’t want use it , you can close it with any value &lt; 1 countCacheExpireInSeconds: the TTL of a count sql statement, the default value is 5 countSuffix : if you custom some count yourself, using it. the default value is **_COUNT** more information you will find out at com.jn.sqlhelper.mybatis.plugins.pagination.PaginationPluginConfig 6.3 MyBatis + Spring Boot 6.3.1 installation import dependencies: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${sqlhelper.version}&lt;/version&gt; &lt;/dependency&gt; configure applcation.yml (Optional): sqlhelper: mybatis: instrumentor: cache-instrumented-sql: true subquery-paging-start-flag: &quot;[PAGING_StART]&quot; subquery-paging-end-flag: &quot;[PAGING_END]&quot; pagination: count: true default-page-size: 10 use-last-page-if-page-no-out: true count-suffix: _COUNT or configure application.properteis (Optional) sqlhelper.mybatis.instrumentor.cacheInstrumentedSql=true sqlhelper.mybatis.instrumentor.dialect=mysql sqlhelper.mybatis.instrumentor.subqueryPagingStartFlag=[PAGING_START] sqlhelper.mybatis.instrumentor.subqueryPagingEndFlag=[PAGING_END] sqlhelper.mybatis.count= true sqlhelper.mybatis.defaultPageSize= 10 sqlhelper.mybatis.countSuffix=_COUNT more configuration reference : Paginagion Configuration、Mybatis specified configuration 6.3.2 Usage @GetMapping(&quot;/_useMyBatis&quot;) public PagingResult list_useMyBatis( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort) { User queryCondition = new User(); queryCondition.setAge(10); PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); List&lt;User&gt; users = userDao.selectByLimit(queryCondition); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } more examples you can find out from UserController class in sqlhelper-exmples 6.4 MyBatis-plus + Spring Boot Application 6.4.1 installation import dependencies: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-mybatisplus-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${sqlhelper.version}&lt;/version&gt; &lt;/dependency&gt; configure applcation.yml (Optional): sqlhelper: mybatis: instrumentor: cache-instrumented-sql: true subquery-paging-start-flag: &quot;[PAGING_StART]&quot; subquery-paging-end-flag: &quot;[PAGING_END]&quot; pagination: count: true default-page-size: 10 use-last-page-if-page-no-out: true count-suffix: _COUNT or configure application.properteis (Optional) sqlhelper.mybatis.instrumentor.cacheInstrumentedSql=true sqlhelper.mybatis.instrumentor.dialect=mysql sqlhelper.mybatis.instrumentor.subqueryPagingStartFlag=[PAGING_START] sqlhelper.mybatis.instrumentor.subqueryPagingEndFlag=[PAGING_END] sqlhelper.mybatis.count= true sqlhelper.mybatis.defaultPageSize= 10 sqlhelper.mybatis.countSuffix=_COUNT more configuration reference : Paginagion Configuration、Mybatis specified configuration 6.4.2 Usage @GetMapping(&quot;/_useMyBatis&quot;) public PagingResult list_useMyBatis( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort) { User queryCondition = new User(); queryCondition.setAge(10); PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); List&lt;User&gt; users = userDao.selectByLimit(queryCondition); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } more examples you can find out from UserController class in sqlhelper-exmples 6.5 Migrate from PageHelper 6.5.1 installation case 1 : mybatis + mybatisPageHelper if your application is (mybatis + mybatisPageHelper ) , migrate your application to sqlhelper, just do this: remove pageHelper dependency add sqlhelper dependency: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-mybatis-over-pagehelper&lt;/artifactId&gt; &lt;version&gt;${project.version}&lt;/version&gt; &lt;/dependency&gt; case 2 : mybatis-plus + mybatisPageHelper remove pageHelper dependency remove all mybatis-plus dependencies add sqlhelper dependencies: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-mybatis-over-pagehelper&lt;/artifactId&gt; &lt;version&gt;${project.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-mybatisplus-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${sqlhelper.version}&lt;/version&gt; &lt;/dependency&gt; more configuration reference : Paginagion Configuration、Mybatis specified configuration 6.6 SpringJDBC Application 6.6.1 installation import dependencies: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-springjdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${sqlhelper.version}&lt;/version&gt; &lt;/dependency&gt; configure applcation.yml (Optional): sqlhelper: springjdbc: instrumentor: cache-instrumented-sql: true subquery-paging-start-flag: &quot;[PAGING_StART]&quot; subquery-paging-end-flag: &quot;[PAGING_END]&quot; pagination: count: true default-page-size: 10 use-last-page-if-page-no-out: true count-suffix: _COUNT or configure application.properteis (Optional) sqlhelper.springjdbc.instrumentor.cacheInstrumentedSql=true sqlhelper.springjdbc.instrumentor.dialect=mysql sqlhelper.springjdbc.instrumentor.subqueryPagingStartFlag=[PAGING_START] sqlhelper.springjdbc.instrumentor.subqueryPagingEndFlag=[PAGING_END] sqlhelper.springjdbc.count= true sqlhelper.springjdbc.defaultPageSize= 10 sqlhelper.springjdbc.countSuffix=_COUNT more configuration reference : Paginagion Configuration 6.6.2 Usage import com.jn.sqlhelper.springjdbc.JdbcTemplate; import com.jn.sqlhelper.springjdbc.NamedParameterJdbcTemplate; import com.jn.sqlhelper.springjdbc.resultset.SqlHelperRowMapperResultSetExtractor; @Autowired private JdbcTemplate jdbcTemplate; @Autowired private NamedParameterJdbcTemplate namedJdbcTemplate; @GetMapping(&quot;/subqueryPagination_useMyBatis&quot;) public PagingResult subqueryPagination_useMyBatis( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort, @RequestParam(value = &quot;count&quot;, required = false) boolean count, @RequestParam(value = &quot;useLastPageIfPageNoOut&quot;, required = false) boolean useLastPageIfPageNoOut) { User queryCondition = new User(); queryCondition.setAge(10); queryCondition.setName(&quot;zhangsan_&quot;); PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); request.subqueryPaging(true); request.setCount(count); request.setUseLastPageIfPageNoOut(useLastPageIfPageNoOut); List&lt;User&gt; users = userDao.selectByLimit_subqueryPagination(queryCondition); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } @GetMapping(&quot;/_useSpringJdbc_rowMapper&quot;) public PagingResult list_useSpringJdbc_rowMapper( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort, @RequestParam(name = &quot;count&quot;, required = false) boolean count, @RequestParam(name = &quot;useLastPageIfPageNoOut&quot;, required = false) boolean useLastPageIfPageNoOut, @RequestParam(name = &quot;testSubquery&quot;, required = false, defaultValue = &quot;false&quot;) boolean testSubquery) { PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); request.setCount(count); request.setUseLastPageIfPageNoOut(useLastPageIfPageNoOut); if (testSubquery) { request.subqueryPaging(true); } StringBuilder sqlBuilder = testSubquery ? new StringBuilder(&quot;select * from ([PAGING_START]select ID, NAME, AGE from USER where 1=1 and age &gt; 10[PAGING_END]) n where name like &#39;zhangsan%&#39; &quot;) : new StringBuilder(&quot;select ID, NAME, AGE from USER where 1=1 and age &gt; 10&quot;); List&lt;User&gt; users = jdbcTemplate.query(sqlBuilder.toString(), new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User u = new User(); u.setId(rs.getString(&quot;ID&quot;)); u.setName(rs.getString(&quot;NAME&quot;)); u.setAge(rs.getInt(&quot;AGE&quot;)); return u; } }); String json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } @GetMapping(&quot;/_useSpringJdbc_pSetter_rExecutor&quot;) public PagingResult list__useSpringJdbc_pSetter_rExecutor( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort) { PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); StringBuilder sqlBuilder = new StringBuilder(&quot;select ID, NAME, AGE from USER where 1=1 and age &gt; ?&quot;); List&lt;User&gt; users = jdbcTemplate.query(sqlBuilder.toString(), new PreparedStatementSetter() { @Override public void setValues(PreparedStatement ps) throws SQLException { ps.setInt(1, 10); } }, new ResultSetExtractor&lt;List&lt;User&gt;&gt;() { @Override public List&lt;User&gt; extractData(ResultSet rs) throws SQLException, DataAccessException { List&lt;User&gt; users = new ArrayList&lt;&gt;(); while (rs.next()) { User u = new User(); u.setId(rs.getString(&quot;ID&quot;)); u.setName(rs.getString(&quot;NAME&quot;)); u.setAge(rs.getInt(&quot;AGE&quot;)); users.add(u); } return users; } }); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); return request.getResult(); } @GetMapping(&quot;/_useSpringJdbc_args_rExecutor&quot;) public PagingResult list__useSpringJdbc_args_rExecutor( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort, @RequestParam(name = &quot;testSubquery&quot;, required = false, defaultValue = &quot;false&quot;) boolean testSubquery) { PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); if (testSubquery) { request.subqueryPaging(true); } StringBuilder sqlBuilder = testSubquery ? new StringBuilder(&quot;select * from ([PAGING_START]select ID, NAME, AGE from USER where 1=1 and age &gt; ?[PAGING_END]) n where name like CONCAT(?,&#39;%&#39;) &quot;) : new StringBuilder(&quot;select ID, NAME, AGE from USER where 1=1 and age &gt; ?&quot;); Object[] args = testSubquery ? new Object[]{10, &quot;zhangsan&quot;} : new Object[]{10}; List&lt;User&gt; users = jdbcTemplate.query(sqlBuilder.toString(), args, new ResultSetExtractor&lt;List&lt;User&gt;&gt;() { @Override public List&lt;User&gt; extractData(ResultSet rs) throws SQLException, DataAccessException { List&lt;User&gt; users = new ArrayList&lt;&gt;(); while (rs.next()) { User u = new User(); u.setId(rs.getString(&quot;ID&quot;)); u.setName(rs.getString(&quot;NAME&quot;)); u.setAge(rs.getInt(&quot;AGE&quot;)); users.add(u); } return users; } }); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); return request.getResult(); } @GetMapping(&quot;/custom_BeanRowMapperTests&quot;) public PagingResult custom_BeanRowMapperTests( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort) { PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); StringBuilder sqlBuilder = new StringBuilder(&quot;select ID, NAME, AGE from USER where 1=1 and age &gt; ?&quot;); BeanRowMapper&lt;User&gt; beanRowMapper = new BeanRowMapper(User.class); List&lt;User&gt; users = jdbcTemplate.query(sqlBuilder.toString(), new PreparedStatementSetter() { @Override public void setValues(PreparedStatement ps) throws SQLException { ps.setInt(1, 10); } }, new SqlHelperRowMapperResultSetExtractor&lt;User&gt;(beanRowMapper)); String json = JSONBuilderProvider.simplest().toJson(request.getResult()); System.out.println(json); System.out.println(JSONBuilderProvider.simplest().toJson(users)); return request.getResult(); } @GetMapping(&quot;/_useSpringJdbcNamedTemplate&quot;) public PagingResult list_useSpringJdbcNamedTemplate( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort, @RequestParam(name = &quot;testSubquery&quot;, required = false, defaultValue = &quot;false&quot;) boolean testSubquery) { PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); if (testSubquery) { request.subqueryPaging(true); } StringBuilder sqlBuilder = testSubquery ? new StringBuilder(&quot;select * from ([PAGING_START]select ID, NAME, AGE from USER where 1=1 and age &gt; :age [PAGING_END]) n where name like CONCAT(:name,&#39;%&#39;) &quot;) : new StringBuilder(&quot;select ID, NAME, AGE from USER where 1=1 and age &gt; :age&quot;); Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;age&quot;, 10); paramMap.put(&quot;name&quot;, &quot;zhangsan&quot;); List&lt;User&gt; users = namedJdbcTemplate.query(sqlBuilder.toString(), paramMap, new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User u = new User(); u.setId(rs.getString(&quot;ID&quot;)); u.setName(rs.getString(&quot;NAME&quot;)); u.setAge(rs.getInt(&quot;AGE&quot;)); return u; } }); String json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } you should sqlhelper’s JdbcTemplate, NamedJdbcTemplate instead of springjdbc’s JdbcTemplate,NamedJdbcTemplate more examples you can find out from UserController class in sqlhelper-exmples 6.7 Apache DBUtils Application 6.7.1 installation import dependencies: &lt;dependency&gt; &lt;groupId&gt;com.github.fangjinuo.sqlhelper&lt;/groupId&gt; &lt;artifactId&gt;sqlhelper-dbutils&lt;/artifactId&gt; &lt;version&gt;${sqlhelper.version}&lt;/version&gt; &lt;/dependency&gt; more configuration reference : Paginagion Configuration 6.7.2 Usage import com.jn.sqlhelper.apachedbutils.QueryRunner; @GetMapping(&quot;/list_useApacheDBUtils&quot;) public PagingResult list_useApacheDBUtils( @RequestParam(name = &quot;pageNo&quot;, required = false) Integer pageNo, @RequestParam(name = &quot;pageSize&quot;, required = false) Integer pageSize, @RequestParam(name = &quot;sort&quot;, required = false) String sort, @RequestParam(name = &quot;testSubquery&quot;, required = false, defaultValue = &quot;false&quot;) boolean testSubquery) throws SQLException { PagingRequest request = SqlPaginations.preparePagination(pageNo == null ? 1 : pageNo, pageSize == null ? -1 : pageSize, sort); if (testSubquery) { request.subqueryPaging(true); } StringBuilder sqlBuilder = testSubquery ? new StringBuilder(&quot;select * from ([PAGING_START]select ID, NAME, AGE from USER where 1=1 and age &gt; ?[PAGING_END]) n where name like CONCAT(?,&#39;%&#39;) &quot;) : new StringBuilder(&quot;select ID, NAME, AGE from USER where 1=1 and age &gt; ?&quot;); DataSource ds = namedJdbcTemplate.getJdbcTemplate().getDataSource(); QueryRunner queryRunner = new QueryRunner(ds); List&lt;Object&gt; params = Collects.emptyArrayList(); params.add(10); if(testSubquery){ params.add(&quot;zhangsan&quot;); } List&lt;User&gt; users = queryRunner.query(sqlBuilder.toString(), new ResultSetHandler&lt;List&lt;User&gt;&gt;() { RowMapperResultSetExtractor extractor = new RowMapperResultSetExtractor&lt;User&gt;(new BeanRowMapper&lt;User&gt;(User.class)); @Override public List&lt;User&gt; handle(ResultSet rs) throws SQLException { return extractor.extract(rs); } }, Collects.toArray(params)); String json = JSONBuilderProvider.simplest().toJson(users); System.out.println(json); return request.getResult(); } you should sqlhelper’s QueryRunner instead of apache commons-dbutils’s QueryRunner. more examples you can find out from UserController class in sqlhelper-exmples 6.8 Usage 6.8.1 PagingRequest the following properties are provided in PagingRequest : dialect {String}, the dialect will be used, the default value is null. count {Boolean}, whether execute select count statement or not, the default value is null. countColumn {String}, the property will be used in the count statement like this: select count(${countColumn}) pageNo {String}, the page will get pageSize {String}, the page size fetchSize {Integer} the JDBC’s fetch size, the default value is null. maxRows {int} the JDBC’s maxRows, the default value is -1 timeout {int} the JDBC’s query timeout, the default value is 0 useLastPageIfPageOut {Boolean}, whether get the last page if the pageNo greate than max page, the default value is null. orderBy {OrderBy} the order by condiation {Any Object} the extra condition isSubQueryPaging {boolean}, whether is a sub query paging request, the default value is false subqueryPagingStartFlag {String} the flag of the subquery paging request, the default value is null. subqueryPagingEndFlag {String} the flag of the subquery paging request, the default value is null. result {PagingResult} the result of the paging request supply 3 request types: empty request, will not execute select statement if pageSize = 0 get all request, will not exeucte pagination reqeust if pageSize &lt; 0 pagination request, will execute an pagination request, if pageSize &gt; 0 6.8.2 PagingResult pageNo {int} current page pageSize {int} the pageSize total the total count items {List} the rows if you want get the max page, just use the getMaxPageCount() method 6.9 How to Integrate sqlhelper pagination SQLStatementInstrumentor provide the following functions: instrument the limit partion to the sql set prepared parameters. build select count sql integrate into a database framework just the following steps: step 1: Get the dialect if is a paging request PagingRequestContext PAGING_CONTEXT = PagingRequestContextHolder.getContext(); boolean isPagingRequest = PAGING_CONTEXT.isPagingRequest()); if(isPagingRequest){ instrumentor.beginIfSupportsLimit(xxx); } PagingRequest pagingRequest = PAGING_CONTEXT.getPagingRequest(); PagingResult result = new PagingResult(); pagingRequest.setResult(result); step 2: execute a select count sql statement if need get the total count String countSql = instrumentor.countSql(sql, pagingRequest.getCountColumn()); int total = query(countSql, SelectCountResultSetExtractor.INSTANCe) result.setTotal(total); step 3: instrument limit partion to a sql RowSelection rowSelection = rowSelectionBuilder.build(pagingRequest); String paginationSql = sql; if (PAGING_CONTEXT.isOrderByRequest()) { paginationSql = instrumentor.instrumentOrderByLimitSql(sql, pagingRequest.getOrderBy(), rowSelection); } else { paginationSql = instrumentor.instrumentLimitSql(sql, rowSelection); } step 4: wrap the preparedstatement (Optional) PreparedStatement ps = new PagedPreparedStatement(this.prepareStatement(conn, paginationSql)); step 5: wrap original parameters as a QueryParameters QueryParameters queryParameters = new ArrayBasedQueryParameters(); queryParameters.setRowSelection(rowSelection); queryParameters.setParameters(params, 0, 0); step 6: set parameters instrumentor.bindParameters(ps, parameterSetter, queryParameters, true); . . . "]
]
